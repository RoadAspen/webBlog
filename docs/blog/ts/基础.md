# Typescript

> 主要为 javascript 添加类型注解及其他一些功能。

## 基础类型

**布尔值**

```js
const a: boolean = true || false;
```

**数值**

> 支持整数和浮点数，二进制、十进制、八进制、十六进制

```js
const a: number = 0 || -1 || 0xef || 0010;
```

**字符串**

> 支持字符串和模板字符串及字符串拼接

```js
const str: string = "string" || `string`;
```

**数组**

> 采用 `type []` 或者 `Array<type>`(数组泛型) 的方式。

```js
// 数字数组
const str: number[] = [1, 2, 3, 4];
// 字符串 数组
const str: string[] = ["a", "b", "c"];
// 布尔值 数组
const str: boolean[] = [true, false, true];
// 多维数组
const str: string[][] = [
	["a", "b"],
	["a", "b", "c"],
];

// 对象数组
const str: Array<{ a: string }> = [{ a: "a" }, { a: "b" }];
```

**元组**

> 允许表示一个`已知元素数量和类型`的数组, 数组的长度是固定的，且每一个元素的类型也是固定的。

```js
let list: [number, string];
list = [1, "a"]; // OK
list = ["a", 1]; // ERROR
```

**枚举**

> enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字.

```js
// Color.Red == 0 , Color.Green == 1
// Color[0] == 'Red' , Color[1] == 'Green'
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
```

**Any**

> 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量:

```js
// any 表示 值可以是任意类型的值。
let a: any;
a = 4; // number
a = "a"; // string
a = true; // boolean
a = [1]; // number[]

// any 可以充当其他类型的子值。
let list: any[];
list = [1, "a", true, ["a"], undefiend]; // 数组的元素可以是任意类型
```

**Void**

> 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型,只能为它赋予 undefined 和 null。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：

```js
// 该函数没有返回任何值，默认为undefined
function warnUser(): void {
	console.log("This is my warning message");
}
//声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null
let a: void;
a = undefined; // OK
a = null; // OK
a = 1; // Error
```

**Null 和 Undefined**

> ypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大.

```js
let a: null = null; // OK
a = 1; // Error

let b: undefined = undefined; // OK
b = null; // Error
```

**Never**

> 表示永不存在的类型，如 循环永远不会停止、抛出异常等。

```js
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
	throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
	return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
	while (true) {}
}
```

**Object**

> 表示非原始类型，使用 Object 则参数就可以使用 Object 上的 API。

```js
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```

**类型断言**

> 我认为一个变量一定是某一种类型，不需要 typescript 类型推断。typescript 会假设你已经有了确定的认知。

```js
// 尖括号表示法
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;

// as type 表示法
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
// 在 jsx中使用时，只允许使用as语法， 尖括号语法会引起jsx解析的冲突。
```

## public、private、static，protected,readonly, abstract 区别

`public` **公有属性**，默认所有的属性都是 public， 任何地方都可以使用

`private` **私有属性**，只有类内部可以使用，子类和实例无法使用

`static` **静态属性**，ES7 新增语法，标识属于类本身的静态属性，不存在于实例和原型链中。

`protected` **受保护的属性**，和 `private`类似，但是可以在子类中使用。

`readonly` **只读属性**，不允许改变

`abstract` **抽象类和抽象属性** abstract 修饰， 抽象类里面可以没有抽象方法。但有抽象方法(abstract method)的类必须声明为抽象类

```js
class A{
	// es7的语法，es6之前只能写在constructor中
	age = 24

	// 私有，只能类内部访问
	private name = 1

    //默认public 类内部、实例及 子类内部、子类实例都可以使用
	public s = 2

	// 属性默认是 public
	public func(){
		this.onclick() // 正常调用
	}
	// private 只能在 类 A中 访问 onclick,在子类中是无法访问，实例也无法直接调用
	private onclick(){
		console.log(this.name) // 正常调用
	}

	// static 直接在类函数上访问 names ， eg： A.names， 在 该函数上不能使用this
	static names(){
		return 2
	}
	// protected 和 private 类似，但是 protected 修饰的方法只能在本类和子类中使用，不能通过实例调用
	protected prote(){
		console.log('这是一个受保护得方法')
	}
}

var ass = new A()
ass.func() // 正常
ass.onclick() // 报错，不能被实例使用
ass.names() // 报错，无方法
ass.prote() // 报错，不能被实例调用
A.names() // 正常， 属于 类的静态方法

class B extends A{
	x = 2
	// 默认 public
	onclicks(){
		console.log(this.name) // 报错， name 是 private属性，不能在这里被获取

		console.log(this.onclick) // 报错 ， onclick 是 private 方法

		console.log(this.prote)  // 正常， 可以在类中方法使用
	}
}
var bsss = new B()
bsss.func() // 正常 ，可以在任何地方调用
bsss.onclicks() // 可以正常调用
bsss.prote() //  报错，不能被实例调用

// Animal 是一个抽象类，没有实例，只能用于被继承
abstract class Animal {
    public name:string;

    // 只读
   	readonly age = 10;

    //抽象方法 ，不包含具体实现，要求子类中必须实现此方法,原型链中不存在
    abstract eat():any;

    //非抽象方法，无需要求子类实现、重写
    run(){
    	this.age = 20; // : Cannot assign to 'age' because it is a read-only property. 不能修改
        console.log('非抽象方法，不要子类实现、重写');
    }
}
// 继承自
abstract class  Dog extends Animal{

    // abstract 子类中不用实现父类抽象方法
    // eat(){
    //    return this.name+"吃肉";
    // }
}

class Cat extends Animal{

    //子类中必须实现父类抽象方法，否则ts编译报错
    eat(){
        return this.name+"吃鱼";
    }
}
```

**private、public、protected 主要区别在于继承以及实例调用， static 是 es 语法，用于在构造函数上添加属性，和原型链无关。 readonly 是不能修改的属性。abstract 是抽象类，被 abstract 修饰的类或者属性只能被继承，继承的子类必须实例抽象类中的抽象方法，如果继承的子类也是 abstract 修饰的类，那么就不用实现，需要子类的子类去实现。**

## interface 接口

interface 对一个对象的形状进行描述，包含 属性、方法。接口可以继承。

```js
interface Animal {
	name: string;
	age: number;
	woff(): undefined;
}
// a 必须要满足 Animal 的要求
const a: Animal = {
	name: "dog",
	age: 23,
	woff: function() {
		console("wangwangwang");
	},
};
// 再次声明 Animal 则可以和之前声明过的合并， 相同的属性，如果类型相同则保留其一，如果类型不同则报错。同名函数合并则类似于函数重载
interface Animal {
	address: string;
	date: string;
}

const b: Animal = {
	name: "dog",
	age: 12,
	woff: function() {
		console("wangwangwang");
	},
	address: "浦东新区",
	date: "2020-12-20",
};

//接口可以继承
interface fish extends Animal {
	need: string;
}

// 继承之后则必须实现所有的属性
const fish1: fish = {
	name: "dog",
	age: 12,
	woff: function() {
		console("wangwangwang");
	},
	address: "浦东新区",
	need: "water",
};

// 由于类实例化后是一个对象，而 interface 也是定义一个对象，那么可以用类直接实化一个 interface。

class Animals implements Animal {
	name = "dog";
	age = 12;
	address = "浦东新区";
	need = "water";
	woff() {
		console.log("wangwnagwang");
	}
}
```

## type 类型别名

type 与 interface 类似，叫做类型别名。

```js
// 联合类型，并用 Person 代替。
type Person = string ｜ number

// 用type 定义对象
type Obj1 = {
    name:Person; // name : string | number
}

type obj2 = {
    age:number
}

// 用type 代替 函数定义
type func = ()=>string;


// type 拓展, 使用 & 拓展type
type all = Obj1 & Obj2


```

## type 和 interface 的区别

**共同点**

1. 都可以定义对象和函数。
2. 都允许拓展，但是语法不同
    - interface extends interface 接口继承接口。
    - type & type 别名联合别名。
    - interface & type 接口拓展别名
    - type extends interface 别名拓展接口
3. 都可以被 class 继承。
   **不同点**
4. type 可以定义很多类型，包含 联合类型、类型别名、枚举类型。
5. type 可以指定为 typeof 的返回值，可以制定任意组合的类型，interface 只能以对象的形式定义。
6. interface 可以声明合并，而 type 不能。

## 泛型的使用

常用于 函数的输出类型与输入类型有一定关系的场景

```js
// 不使用泛型
function identity(arg: number): number {
	return arg;
}

// 使用泛型, 用T表示输入类型， 在尖括号内指定输入T的类型
function identity<T>(arg: T): T {
	return arg;
}
let name = "name";
// 指明输入的类型为 string
const a = identity < string > name;

// 也可以不指明类型，利用类型推论。自行推导处 T的类型

const b = identity(name);
```

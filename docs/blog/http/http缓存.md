# HTTP 缓存：按缓存位置分类详解

HTTP 缓存是提高 Web 性能的重要机制，按照缓存位置可以分为 `memory cache`（内存缓存）、`disk cache`（磁盘缓存）、`service worker`（服务工作线程缓存）三类。以下是对这三类缓存的详细介绍及对比：

## 一、memory cache（内存缓存）

### 1. 工作原理

内存缓存是浏览器将资源存储在内存中，当请求再次到来时，优先从内存中查找并返回资源。由于内存的读写速度极快，所以内存缓存的响应速度非常高。例如，当用户在一个页面中频繁切换不同的标签页，且这些标签页中包含相同的图片、脚本等资源时，这些资源可能会被缓存在内存中，以便快速加载。

### 2. 特点

- **快速响应**：因为数据存储在内存中，读取速度快，能实现几乎瞬间的响应，极大提升用户体验。
- **生命周期短**：内存缓存的生命周期与浏览器进程相关。当浏览器关闭或者标签页被关闭时，内存缓存中的数据会被立即释放。此外，当浏览器内存不足时，也会自动清理内存缓存中的数据，以释放内存空间。
- **存储容量有限**：由于内存资源相对宝贵，所以内存缓存的存储容量较小，只能存储一些体积较小、访问频繁的资源。

### 3. 命中缓存示例

当你在浏览器中打开一个网页，该网页引用了一个外部的 JavaScript 文件 `main.js`。第一次请求时，浏览器从服务器下载该文件，并将其存储在内存缓存中。当你刷新页面或者在同一浏览器窗口中打开另一个引用了相同 `main.js` 文件的页面时，浏览器会首先检查内存缓存，若命中则直接从内存中读取该文件，而不会再次发起网络请求。

### 4. 使用示例

在开发中，我们可以通过浏览器的开发者工具（如 Chrome 的开发者工具）来观察内存缓存的使用情况。当你打开一个页面后，在 Network 面板中勾选 “Disable cache” 取消勾选状态，然后刷新页面，查看资源的加载情况。如果某个资源的 Size 显示为 “from memory cache”，则表示该资源是从内存缓存中获取的。

### 5. 适用场景

适合缓存一些频繁使用且体积较小的资源，如页面的基本样式表（CSS）、关键的 JavaScript 脚本等。这些资源在页面加载和交互过程中会被多次访问，通过内存缓存可以快速获取，提高页面的响应速度。

## 二、disk cache（磁盘缓存）

### 1. 工作原理

磁盘缓存是将资源存储在本地磁盘上。当浏览器请求一个资源时，首先检查磁盘缓存中是否存在该资源，如果存在且未过期，则直接从磁盘中读取并返回；如果不存在或者已过期，则重新发起网络请求获取资源，并将其存储在磁盘缓存中，以便下次使用。

### 2. 特点

- **容量较大**：相对于内存缓存，磁盘的存储空间要大得多，可以存储更多的资源，包括较大的图片、视频文件等。
- **持久性强**：数据存储在磁盘上，只要不主动清理或者磁盘空间不足导致缓存被清除，数据就会一直存在。即使浏览器关闭后重新打开，磁盘缓存中的数据仍然可用。
- **读取速度相对较慢**：虽然磁盘的读写速度在不断提高，但与内存相比，仍然存在一定的差距。在读取磁盘缓存时，会有一定的延迟。

### 3. 命中缓存示例

假设你访问一个新闻网站，该网站上有一张较大的新闻图片 `news.jpg`。第一次访问时，浏览器从服务器下载该图片，并将其存储在磁盘缓存中。当你在几天后再次访问该新闻页面，或者访问该网站的其他页面中引用了相同的 `news.jpg` 图片时，浏览器会检查磁盘缓存，若该图片未过期且存在于磁盘缓存中，则直接从磁盘中读取该图片，而不会再次发起网络请求。

### 4. 使用示例

同样可以使用浏览器的开发者工具来观察磁盘缓存的使用情况。在 Network 面板中，若某个资源的 Size 显示为 “from disk cache”，则表示该资源是从磁盘缓存中获取的。

### 5. 适用场景

适用于缓存一些不经常变化且体积较大的资源，如网站的 logo 图片、一些静态的脚本库等。这些资源不需要频繁更新，且占用空间较大，通过磁盘缓存可以减少网络请求，降低带宽消耗。

## 三、service worker（服务工作线程缓存）

### 1. 工作原理

`service worker` 是运行在浏览器后台的独立线程，它可以拦截网络请求，并根据事先设定的缓存策略来决定是从网络获取资源还是从缓存中读取资源。`service worker` 可以在用户离线时提供缓存的资源，实现离线浏览功能。例如，当用户打开一个已经缓存过的网页时，即使处于离线状态，`service worker` 也能从缓存中获取资源并展示给用户。

### 2. 特点

- **离线可用**：这是 `service worker` 最显著的特点。它可以在用户没有网络连接的情况下，提供缓存的页面和资源，保证用户的基本浏览体验。
- **灵活的缓存策略**：开发者可以根据具体需求，自定义各种缓存策略，如先从缓存中获取资源，如果没有再从网络请求；或者先从网络请求，成功后再更新缓存等。
- **需要编程实现**：使用 `service worker` 需要一定的编程知识，开发者需要编写相应的 JavaScript 代码来注册、配置和管理 `service worker`。

### 3. 命中缓存示例

以下是一个简单的 `service worker` 代码示例，展示了如何实现缓存策略：

```javascript
// service-worker.js
self.addEventListener('install', (event) => {
	event.waitUntil(
		caches.open('my-cache-v1').then((cache) => {
			return cache.addAll(['/', '/index.html', '/styles.css', '/main.js']);
		})
	);
});

self.addEventListener('fetch', (event) => {
	event.respondWith(
		caches.match(event.request).then((response) => {
			return response || fetch(event.request);
		})
	);
});
```

在这个示例中，当 `service worker` 安装时，会将指定的资源（如 `index.html`、`styles.css`、`main.js` 等）缓存起来。当浏览器发起请求时，`service worker` 会拦截该请求，首先检查缓存中是否存在对应的资源，如果存在则直接返回缓存的资源，即命中缓存。

### 4. 使用示例

在主页面的 JavaScript 文件中注册 `service worker`：

```javascript
// main.js
if ('serviceWorker' in navigator) {
	window.addEventListener('load', () => {
		navigator.serviceWorker
			.register('/service-worker.js')
			.then((registration) => {
				console.log(
					'Service Worker registered with scope:',
					registration.scope
				);
			})
			.catch((error) => {
				console.error('Service Worker registration failed:', error);
			});
	});
}
```

### 5. 适用场景

适用于需要实现离线浏览功能的 Web 应用，如新闻类应用、阅读类应用等。这些应用可以在用户有网络连接时提前缓存好相关的内容，当用户离线时仍然可以浏览已缓存的文章、新闻等。

## 四、优先级

一般情况下，缓存的查找顺序是 `service worker` > `memory cache` > `disk cache`。当浏览器发起一个请求时，会首先检查 `service worker` 是否拦截该请求并返回缓存资源；如果没有命中 `service worker` 缓存，则检查内存缓存；若内存缓存也未命中，则检查磁盘缓存；如果所有缓存都未命中，则发起网络请求获取资源。

## 五、对比总结

| 缓存类型       | 存储位置       | 响应速度       | 存储容量 | 数据持久性                     | 适用场景                 | 实现难度           | 命中标识          |
| -------------- | -------------- | -------------- | -------- | ------------------------------ | ------------------------ | ------------------ | ----------------- |
| memory cache   | 内存           | 快             | 小       | 短，随浏览器进程或内存情况变化 | 频繁使用且体积小的资源   | 无，浏览器自动管理 | from memory cache |
| disk cache     | 磁盘           | 较快           | 大       | 长，除非主动清理或空间不足     | 不经常变化且体积大的资源 | 无，浏览器自动管理 | from disk cache   |
| service worker | 浏览器后台线程 | 取决于缓存策略 | 较大     | 长，可自定义管理               | 离线浏览需求的应用       | 有，需编程实现     | 自定义逻辑控制    |

通过合理利用这三种不同类型的 HTTP 缓存，可以根据资源的特点和应用的需求，选择最合适的缓存方式，从而提高 Web 应用的性能和用户体验。

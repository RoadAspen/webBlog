# HTTP、HTTP1.0、HTTP1.1、HTTP2、HTTPS

# HTTP 协议

`超文本传输协议` 是互联网上应用最为广泛的一种网络协议，所有的 www 文件都必须遵守这个标准，默认使用 80 端口， HTTP 客户端发起一个请求，建立一个到服务器指定端口的 TCP 连接。HTTP 是在 TCP 协议上建立的，HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性。
UDP 由于不对传输数据做处理，所以不利于数据解析、和错误纠正。
`HTTP` 使用的是 **请求-响应**的方式，不仅在请求时先建立连接，而且需要客户端向服务器发出请求后，服务端才能恢复数据。 HTTP1.0 、HTTP1.1、HTTP2.0 都是基于 HTTP 协议上做进一步优化的。

# HTTP1.0

HTTP 协议老的标准是 HTTP/1.0，为了提高系统的效率，HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。

#### 优点

支持浏览器与服务器之间通信，并通过对返回值的整合，梳理出适合处理的 http 请求报文。

#### 缺点

1. `请求独立`
   **每次请求都要重新建立一个连接**，走一遍 TCP 三次握手->发请求->返回请求结果->四次挥手关闭连接。每个 HTML 页面渲染的时候，会将 link、script、img 等地址对应建立连接，如果页面资源过多，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。当一个网页文件中包含 JavaScript 文件，CSS 文件等内容时，也会出现类似上述的情况。
2. `带宽延迟`  
   客户端是依据域名来向服务器建立连接，一般 PC 端浏览器会针对单个域名的 server 同时建立 6 ～ 8 个连接，手机端的连接数则一般控制在 4 ～ 6 个。显然连接数并不是越多越好，资源开销和整体延迟都会随之增大。**连接无法复用会导致每次请求都经历三次握手和慢启动**。

# HTTP1.1

为了克服 HTTP 1.0 的一个请求一个独立连接，tcp 不能复用的缺点，HTTP 1.1 支持持久连接（HTTP/1.1 的默认模式使用带流水线的持久连接），通过 http 头部 connection keep-alive，在一个 TCP 连接上，只要这个 TCP 连接不断开，那么就可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。**一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接**。**HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间**。

在 http1.1，request 和 reponse 头中都有可能出现一个 connection 的头，此 header 的含义是当 client 和 server 通信时对于长链接如何进行处理。
**在 http1.1 中，client 和 server 都是默认对方支持长链接的**， 如果 client 使用 http1.1 协议，但又不希望使用长链接，则需要在 header 中指明 connection 的值为 close；如果 server 方也不想支持长链接，则在 response 中也需要明确说明 connection 的值为 close。不论 request 还是 response 的 header 中包含了值为 close 的 connection，都表明当前正在使用的 tcp 链接在当天请求处理完毕后会被断掉。以后 client 再进行新的请求时就必须创建新的 tcp 链接了。

HTTP 1.1 在继承了 HTTP 1.0 优点的基础上，也克服了 HTTP 1.0 的性能问题。HTTP 1.1 通过增加更多的请求头和响应头来改进和扩充 HTTP 1.0 的功能。如，**HTTP 1.0 不支持 Host 请求头字段**，WEB 浏览器无法使用主机头名来明确表示要访问服务器上的哪个 WEB 站点，这样就无法使用 WEB 服务器在同一个 IP 地址和端口号上配置多个虚拟 WEB 站点。**在 HTTP 1.1 中增加 Host 请求头字段后**，WEB 浏览器可以使用主机头名来明确表示要访问服务器上的哪个 WEB 站点，这才实现了在一台 WEB 服务器上可以在同一个 IP 地址和端口号上使用不同的主机名来创建多个虚拟 WEB 站点。HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，`Connection`请求头的值为`Keep-Alive`时，客户端通知服务器返回本次请求结果后保持连接；`Connection`请求头的值为`close`时，客户端通知服务器返回本次请求结果后关闭连接。**HTTP 1.1 还提供了与身份认证、状态管理和 Cache 缓存等机制相关的请求头和响应头**。HTTP/1.0 不支持文件断点续传，`<code>RANGE:bytes</code>`是 HTTP/1.1 新增内容，HTTP/1.0 每次传送文件都是从文件头开始，即 0 字节处开始。`<code>RANGE:bytes=XXXX</code>`表示**要求服务器从文件 XXXX 字节处开始传送，这就是我们平时所说的断点续传**！

由上，HTTP/1.1 相较于 HTTP/1.0 协议的区别主要体现在：

1. 缓存处理, `新增强缓存和协商缓存请求头`

2. 带宽优化及网络连接的使用, `增加长连接,多个请求可以在同一个连接中发送`

3. 错误通知的管理， `新增状态码，极大丰富了 返回码的含义`

4. 消息在网络中的发送， `链接可以并行发送，但是返回时按发送顺序返回，端点续传`

5. 互联网地址的维护 `新增host字段，可以识别多个域名对应统一个ip地址，方便nginx根据域名做转发。`

6. 安全性及完整性 `新增身份验证 Authorition 字段`

7. Restfull api 指出 `新增多种操作资源的方法 DELETE、PATCH、PUT、HEAD等`

# HTTP2

> HTTP2 在 HTTP1.1 的基础上做了大幅度的改版，极大的提升了请求速度，也为网站性能优化提供了新的方向。

1. 增加二进制分帧。
2. 首部压缩。
    - 将首部字段也压缩，这样就可以减小传输的流量
3. 流量控制。
4. 多路复用。
    - 共享 TCP 连接,一个 TCP 连接可以同时并发多个请求。
5. 请求优先级
    - css > js > jpg
6. 服务器推送
    - 如果客户端请求 html，则会将 html，以及 html 内部可能用到的 css，js 一起返回，减少二次请求时间。

# HTTPS

> HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。

1. TCP 三次同步握手
2. 客户端验证服务器数字证书
3. DH 算法协商对称加密算法的密钥、hash 算法的密钥
4. SSL 安全加密隧道协商完成
5. 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改。

## HTTPS 与 HTTP 的区别

1.HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源.

2. HTTP 的端口号是 80，HTTPS 是 443 端口。
3. HTTPS **需要到 CA 申请证书**，一般免费证书很少，需要交费,使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。.
4. HTTPS 的连接很简单，是无状态的,而且是**明文传输**；HTTPS 协议是由 **SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协**议，比 HTTP 协议安全。
5. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包.
6. HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源

#### HTTPS 请求流程

1、客户端发起 HTTPS 请求

这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。

2、服务端的配置

采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。

这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3、传送证书

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等，此时使用非对称加密，由于非对称加密算法比较消耗性能，所以在传输**公钥和客户端的随机值**之后，使用对称加解密算法。

4、客户端解析证书

这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。

如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

5、传送加密信息

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6、服务端解密信息

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行**对称加密**，所谓对称加密就是**加解密用同一串私钥**，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7、传输加密后的信息

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

8、客户端解密信息

客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

**SSL 证书是在服务端配置，一般情况下会在 nginx 中配置。**

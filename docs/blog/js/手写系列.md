# 手写系列

## new

使用 new 调用函数

> new 操作符实际上执行了以下步骤

```javascript
function _new(fn, ...args) {
  //先创建一个对象
  var obj = {};
  obj.__proto__ = fn.prototype;
  var res = fn.apply(obj, args);
  // 返回 res
  return res instanceof Object ? res : obj;
}
```

## call

> call 为了改变函数中的 this 指向。思路为将函数赋予新对象的同名属性，这是 this 会自动绑定到新对象上边，该实现为精简版，具体容错处理可以自行扩充,需要直接执行，所以绑定成功之后直接执行。

```js
Function.prototype.mycall = function() {
  // 将传入的参数转换为数组
  var args = [...arguments];
  // 保存函数此时this指向函数本身上下文
  var ctx = this;
  // 创建一个名称，Symbol创建不会重复
  var name = Symbol("name");
  // 获取传入的this指向
  var new_ctx = args[0] || window;
  // 我们只需要把this指向新的对象
  new_ctx[name] = ctx;
  // 将 剩余参数分隔出来
  var residue_args = args.slice(1);
  // 传入剩余参数
  const result = new_ctx[name](...residue_args);
  // 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
  delete new_ctx[name];

  return result;
};
```

## apply

> 与 call 的唯一区别就是参数的不同

```js
Function.prototype.myapply = function() {
  if (typeof this !== "function") {
    throw new TypeError("this no a function");
  }
  // 将传入的参数转换为数组
  var args = [...arguments];
  // 保存函数此时this指向函数本身
  var ctx = this;
  // 创建一个名称，Symbol创建不会重复
  var name = Symbol("name");
  // 获取传入的this指向
  var new_ctx = args[0] || window;
  // 我们只需要把this指向新的对象
  new_ctx[name] = ctx;
  // 将第二个参数取出来
  var residue_args = args[1];
  // 传入剩余参数
  const result = new_ctx[name](...residue_args);
  // 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
  delete new_ctx[name];

  return result;
};
```

## bind

> bind 在于不会立即执行，而会在未来某个时间位置执行。所以需要返回一个函数。

```js
Function.prototype.mybind = function() {
  if (typeof this !== "function") {
    throw new TypeError("this no a function");
  }
  // 将传入的参数转换为数组
  var args = [...arguments];
  // 保存函数此时this指向函数本身
  var ctx = this;
  // 创建一个名称，Symbol创建不会重复
  var name = Symbol("name");
  // 获取传入的this指向
  var new_ctx = args[0] || window;
  // 我们只需要把this指向新的对象
  new_ctx[name] = ctx;
  // 将剩余参数取出来
  var residue_args = args.slice(1);
  var new_func = function() {
    return new_ctx[name](...residue_args);
  };
  // 将原函数的原型复制到新函数上
  new_func.prototype = ctx.prototype;
  return new_func;
};
```

## object.create

> 从某一个对象处创建新的对象，将该对象作为新对象的\_\_proto\_\_。

```js
Object.prototype.mycreate = function(obj) {
  function F() {}
  F.prototype = obj;
  // 相当于 newobj.__proto = obj
  return new F();
};
```

## extends

> es6 继承, 用一类继承自另一个类

```js
function extends(Target, Origin) {
  function F() {}
  F.prototype = Origin.prototype;
  Target.prototype = new F();
  Target.prototype.constructor = Target;
}
```

## sleep

> js 单线程，所以要想实现 sleep，则需要定义一个阻塞 js 线程指定时间的程序

```js
function sleep(time) {
  const start = new Data().getTime();
  // 当时间没到时，while循环一直执行，且一直跳出，直到时间到了
  while (new Date().getTime() - time * 1000 < start) {
    continue;
  }
}
console.log("睡眠前");
sleep(2);
console.log("睡眠后");
```

## instanceOf

> instanceOf 用来判断一个构造函数的 prototype 属性所指向的对象是否存在与检测对象的原型链上。

```js
function myInstanceOf(left, right) {
  // left 是检测对象，通过对检测对象原型链查找是否存在 right.prototype
  let proto = left.__proto__;
  let prototype = right.prototype;
  // 使用 while true 代替递归
  while (true) {
    if (proto === null) {
      return false;
    }
    if (proto === prototype) {
      return true;
    }
    proto = proto.__proto__;
  }
}
```

## debounce

> 防抖 在事件被触发 n 秒后再执行回调，如果在这 n 秒内再次触发，则重新计时。 生活中：如电梯关门，每次进人都会重新等待一段时间关门。

```js
function debounce(fn, wait = 1000) {
  let timer; // 定一个空定时器
  return function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, wait);
  };
}

let diantiguanmen = debounce(function() {
  console.log("关门");
}, 10000);

if (有人来了) {
  diantiguanmen();
}
```

## throttle

> 节流。 事件被触发 n 秒后再执行回调，如果在这 n 秒内再次触发，则不做任何反应，直到 n 秒后再接受新的事件触发指令。
> 高频事件触发，一段时间内只执行一次

```js
// 利用定时器
function throttle(fn, wait = 1000) {
  let timer;
  return function() {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, arguments);
      }, wait);
    }
  };
}

// 
```

# 手写 call,apply,bind

> `call,apply,bind` 都是为了改变函数中的 this 指向，不同的是 call，apply 是立即执行，且 call 的参数是分开的，而 apply 的参数是一个数组。 bind 是淡出的绑定 this，但并不执行。

`思路为将函数赋予新对象的同名属性，这是 this会自动绑定到新对象上边，该实现为精简版，具体容错处理可以自行扩充`

## call

> 需要直接执行，所以绑定成功之后直接执行

```js
Function.prototype.mycall = function() {
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 获取函数的名称
	var name = ctx.name;
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将 剩余参数分隔出来
	var residue_args = args.slice(1);
	// 传入剩余参数
	new_ctx[name](...residue_args);
	// 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
	delete new_ctx[name];
};
```

如果新对象恰好存在这个属性，则会将原属性覆盖，出现副作用，所以可以将函数名做一个 hash，这样就不会出现覆盖的现象。

## apply

> 与 call 的唯一区别就是参数的不同

```js
Function.prototype.myapply = function() {
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 获取函数的名称
	var name = ctx.name;
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将第二个参数取出来
	var residue_args = args[1];
	// 传入剩余参数
	new_ctx[name](...residue_args);
	// 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
	delete new_ctx[name];
};
```

如果新对象恰好存在这个属性，则会将原属性覆盖，出现副作用，所以可以将函数名做一个 hash，这样就不会出现覆盖的现象。

## bind

> bind 在于不会立即执行，而会在未来某个时间位置执行。所以需要返回一个函数。

```js
Function.prototype.mybind = function() {
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 获取函数的名称
	var name = ctx.name;
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将剩余参数取出来
	var residue_args = args.slice(1);
	var new_func = function() {
		return new_ctx[name](...residue_args);
	};
	return new_func;
};
```

如果新对象恰好存在这个属性，则会将原属性覆盖，出现副作用，所以可以将函数名做一个 hash，这样就不会出现覆盖的现象。

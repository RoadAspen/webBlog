# new 做了什么？

> 正常使用

```javascript
function People(name) {
	this.name = name;
}
People.prototype.sayHello = function() {
	console.log(`${this.name} ,你好！`);
};
const people1 = new People("RoadAspen");
```

在这里使用了 new 将 People 这个构造函数创建了一个对象。

> new 操作符实际上执行了以下步骤

```javascript
//先创建一个对象
var obj = {};
// 将obj的原型对象指向 People的prototype，可以访问People的原型sayHello方法
// 这样obj就可以访问到 People的原型方法
obj.__proto__ = People.prototype;
// 执行people的构造函数，并将this指向obj
var res = People.call(obj, "RoadAspen");
// 返回 res
return typeof res === "object" ? res : obj;
```

# 手写 call,apply,bind

> `call,apply,bind` 都是为了改变函数中的 this 指向，不同的是 call，apply 是立即执行，且 call 的参数是分开的，而 apply 的参数是一个数组。 bind 是淡出的绑定 this，但并不执行。

`思路为将函数赋予新对象的同名属性，这是 this会自动绑定到新对象上边，该实现为精简版，具体容错处理可以自行扩充`

## call

> 需要直接执行，所以绑定成功之后直接执行

```js
Function.prototype.mycall = function() {
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 获取函数的名称
	var name = ctx.name;
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将 剩余参数分隔出来
	var residue_args = args.slice(1);
	// 传入剩余参数
	new_ctx[name](...residue_args);
	// 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
	delete new_ctx[name];
};
```

如果新对象恰好存在这个属性，则会将原属性覆盖，出现副作用，所以可以将函数名做一个 hash，这样就不会出现覆盖的现象。

## apply

> 与 call 的唯一区别就是参数的不同

```js
Function.prototype.myapply = function() {
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 获取函数的名称
	var name = ctx.name;
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将第二个参数取出来
	var residue_args = args[1];
	// 传入剩余参数
	new_ctx[name](...residue_args);
	// 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
	delete new_ctx[name];
};
```

如果新对象恰好存在这个属性，则会将原属性覆盖，出现副作用，所以可以将函数名做一个 hash，这样就不会出现覆盖的现象。

## bind

> bind 在于不会立即执行，而会在未来某个时间位置执行。所以需要返回一个函数。

```js
Function.prototype.mybind = function() {
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 获取函数的名称
	var name = ctx.name;
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将剩余参数取出来
	var residue_args = args.slice(1);
	var new_func = function() {
		return new_ctx[name](...residue_args);
	};
	return new_func;
};
```

如果新对象恰好存在这个属性，则会将原属性覆盖，出现副作用，所以可以将函数名做一个 hash，这样就不会出现覆盖的现象。

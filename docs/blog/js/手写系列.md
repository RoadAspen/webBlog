# 手写系列

## new

使用 new 调用函数

> new 操作符实际上执行了以下步骤

```javascript
function _new(fn, ...args) {
	//先创建一个对象
	var obj = {};
	obj.__proto__ = fn.prototype;
	var res = fn.apply(obj, args);
	// 返回 res
	return res instanceof Object ? res : obj;
}
```

## call

> call 为了改变函数中的 this 指向。思路为将函数赋予新对象的同名属性，这是 this 会自动绑定到新对象上边，该实现为精简版，具体容错处理可以自行扩充,需要直接执行，所以绑定成功之后直接执行。

```js
Function.prototype.mycall = function() {
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身上下文
	var ctx = this;
	// 创建一个名称，Symbol创建不会重复
	var name = Symbol("name");
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将 剩余参数分隔出来
	var residue_args = args.slice(1);
	// 传入剩余参数
	const result = new_ctx[name](...residue_args);
	// 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
	delete new_ctx[name];

	return result;
};
```

## apply

> 与 call 的唯一区别就是参数的不同

```js
Function.prototype.myapply = function() {
	if (typeof this !== "function") {
		throw new TypeError("this no a function");
	}
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 创建一个名称，Symbol创建不会重复
	var name = Symbol("name");
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将第二个参数取出来
	var residue_args = args[1];
	// 传入剩余参数
	const result = new_ctx[name](...residue_args);
	// 执行成功之后需要删除，否则会在新对象的属性中出现这个方法。
	delete new_ctx[name];

	return result;
};
```

## bind

> bind 在于不会立即执行，而会在未来某个时间位置执行。所以需要返回一个函数。

```js
Function.prototype.mybind = function() {
	if (typeof this !== "function") {
		throw new TypeError("this no a function");
	}
	// 将传入的参数转换为数组
	var args = [...arguments];
	// 保存函数此时this指向函数本身
	var ctx = this;
	// 创建一个名称，Symbol创建不会重复
	var name = Symbol("name");
	// 获取传入的this指向
	var new_ctx = args[0] || window;
	// 我们只需要把this指向新的对象
	new_ctx[name] = ctx;
	// 将剩余参数取出来
	var residue_args = args.slice(1);
	var new_func = function() {
		return new_ctx[name](...residue_args);
	};
	// 将原函数的原型复制到新函数上
	new_func.prototype = ctx.prototype;
	return new_func;
};
```

## object.create

> 从某一个对象处创建新的对象，将该对象作为新对象的\_\_proto\_\_。

```js
Object.prototype.mycreate = function(obj) {
	function F() {}
	F.prototype = obj;
	// 相当于 newobj.__proto = obj
	return new F();
};
```

## extends

> es6 继承

```js
Object.prototype.mycreate = function(obj) {
	function F() {}
	F.prototype = obj;
	// 相当于 newobj.__proto = obj
	return new F();
};
```

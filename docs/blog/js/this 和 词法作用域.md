# this指向问题

+ **词法作用域和this**
    - javascript 的 函数在定义时所处的上下文环境就是 闭包返回函数时的可访问作用域 。
    - 函数执行时，是基于函数定义时的词法作用域 执行的 。
    - 所以 js 的函数作用域是 静态的，当函数定义时，这个函数的词法作用域已经固定了 。
    - 动态词法作用域 是指 在函数在运行时所处的上下文环境的变化会影响到函数的运行结果 。
    - js 函数的词法作用域是静态的，而函数中的this 却是动态的。this 是js最复杂的机制之一 。
    - 函数中的this是在函数执行时的上下文对象指定的。关于this的指向，可以通过  1、调用函数时最近的对象。2、使用 bind ，apply ，call 改变 this 的指向。3、使用 箭头函数 。
    - 关于箭头函数，是指将 函数中的this永久绑定在 定义箭头函数时的词法作用域，无论箭头函数在哪里执行，this都指向定义时的上下文对象 。
    - 在函数中使用this，可以 优雅的方式来隐式传递一个对象引用。使用call或者apply，可以将this指向传递的第一个参数 。
    - this 只是函数上下文对象的一个引用。和函数本身并没有什么大的关系。 在 函数内部引用函数本身的场景主要是 1、 递归。 2、和调用一次之后就自己解除绑定的事件处理器。如 v-once 的实现 v-click.once 的实现 。当给函数添加一些属性之后，在 函数内部访问this ，却无法获得这些添加的属性，就是因为this并不是指的函数，而是函数所处环境的上下文对象。如果没有上下文对象，则this指向 windows全局对象。
    - setTimeout 和 setInterval 中的回调函数是以 eval 的方式传入的，所以 setTImeout 和 setInterval 执行时，都是将传入的回调函数以字符串的样式去解析为 函数再执行，此时 函数内部的this是指向全局的windows
    - this 的指向完全取决于函数在哪里被调用！！！！！！！！！。 所以要查看this的指向，首先需要弄清楚函数的调用位置。而有些编程模式会隐藏真正的调用位置。所以需要分析调用栈。调用栈就是为了到达当前执行位置所调用的所有函数。我们关心的调用位置就在当前正在执行的函数的前一个调用中。this 的执行函数，在调用的位置。如果this 的执行函数是 直接执行的，没有被其他对象调用或者是apply，call，bind。那么this就会执行默认绑定，即绑定到window全局对象。如果是 严格模式，则this指向undefined.无法使用默认绑定，主要是在于this 的执行函数中执行严格模式。
    - 对象属性引用链中只有最顶层（最后一层，离函数最近的一次）会影响调用位置。

### this 绑定 
+ 绑定方式
    - `默认绑定`（直接调用，不依附与任何链式调用）,非严格模式下，指向window，严格模式下指向 undefined 。 
    - `隐式绑定`(通过对象属性的方式执行函数,this 则会默认绑定到调用对象上边）。
    - `隐形丢失`(隐性的触发了默认绑定),被隐式绑定的this会出现隐形丢失的情况 在 一、作为对象属性赋值给其他变量并被调用时，会触发默认绑定。二、在作为函数参数传递并调用时，会触发默认绑定。三、作为 setTimeout 和 setInterval 的参数函数时，会触发默认绑定 。
    - `显示绑定` 调用call，apply,显式的将this绑定到指定的对象上。但是不能解决隐式丢失的问题。
    - `硬绑定` 可以将显式绑定 写在函数中，那么执行函数时，就相当于执行了显示绑定，就不会出现隐形丢失的问题。 这种方式为`硬绑定`。`硬绑定`主要就是在显示绑定外边包裹了一层函数，无论如何调用这个函数，它总会手动的绑定到call和apply指定的对象上。硬绑定是非常常用的模式，ES5 中新增的bind 出现就是硬绑定的语法糖。Function.prototype.bind（obj） 就是根据硬绑定的原理实现的。
    - `API 调用的上下文`，内部实现的显式硬绑定。例如 Array.forEach(fn[,thisArg]) thisArg 是 用来指定 fn内部的this指向对象，在 fn内部调用this时，就会指向 thisArg。这种形式就和 bind一样，确保回调函数使用指定的this。
    - `new 绑定`, new 会将 构造函数实例化为一个对象，函数中的this就是指向了这个实例化的对象。 并不存在 构造函数，只是因为 new 是对函数的构造调用。

### new 绑定  
1. 首先创建一个全新的对象。  var obj = {}
2. 将 构造函数 调用apply ，将 函数内的this绑定到 全新的对象。 并将参数传进去。  fn.apply(obj,[args])
3. 将 新对象的prototype 赋值为 函数的 prototype，执行函数的原型链接  obj.__proto__ = fn.prototype
4. 返回这对象 或者是 空对象。 return typeof obj === 'object' ? obj : {}


> 优先级   new > 显式硬绑定 bind > 显式绑定 call,apply > 隐式绑定 > 默认绑定

#### 被忽略的this
+ 当传入的对象为null或者 undefined 时
    - 实际应用的是默认绑定，比较危险。
    - 使用bind 可以使函数 柯里化 ,bind 和call 类似，但是并不会直接执行，所以 通过 bind传入的参数可以 优先传入一些预定参数，在函数真正执行时再传入另外的参数。
    - 使用apply 可以将数组展开作为参数传递进函数中。

+ 如果只是为了把数组展开成参数，或者函数柯里化，那么就可以传入一个 空对象。
    - 传入 {} 或者 Object.create(null) .
    - 推荐使用 Object.create(null) ，因为它没有 Object.prototype, 比 {} 更空。

#### 箭头函数
+ 箭头函数根据外层作用域来决定this。
    - 箭头函数的词法作用域与普通函数的词法作用域是相同的。
    - 箭头函数的this 则指向箭头函数产生时的this，且一直保留，不能被改变。
    - 箭头函数常用来解决`默认绑定`和`隐形丢失`, 如果定时器的回调函数。
    - 箭头函数与ES6之前的 将this赋值给一个变量，然后通过变量访问this的方法机制是一样的。
# javascript 运行进制 EventLoop

## 一、为什么 javascript 是单线程

js 诞生之初就是单线程，同一时间只能做一件事，为什么 js 要是单线程？  
js 的单线程主要在于 js 的用途，js 作为浏览器脚本语言，主要用途是为了用户互动、操作 DOM，这决定了它只能是单线程，如果是多线程，那么两个线程同时对同一个 DOM 节点作出修改，一个添加，一个删除，那么浏览器该如何做出展示？  
基于此，javascript 从诞生之初就是单线程，这已经是 javascript 这门语言的核心特征，将来也不会改变。  
为了利用多核 CPU 的计算能力，HTML5 提出了 WebWorker 标准，允许 javascript 创建多个线程，但是 web worker 不能操作 DOM，且子线程完全受主线程控制，本质上并没有改变 javascript 是单线程的事实。

## 二、任务队列

**javascript 是单线程**，单线程就意味着，所有的任务都需要排队，当前一个任务结束，下一个任务才会开始执行。如果一个任务耗时过长，后边的任务就会一直等着。  
任务一般分为 **CPU 计算任务**，**网络请求任务** ，如果是 CPU 计算任务时间较长，那就没有办法了。但如果是网络请求任务，要等待结果返回再往下执行。 这种机制就会很浪费时间和机器性能，尤其是在网络环境不好的情况。于是 javascript 设计者就意识到，当执行网络请求任务时，主线程可以不需要等待返回结果，先执行排在后面的任务，只需要在结果返回时再返回执行后续的任务就行了。  
于是，所有的任务分为两种，一种是**同步任务**，一种是**异步任务**。_同步任务指的是，在主线程上排队执行的任务，只有钱一个任务执行完成，下一个任务才可以执行_。_异步任务指的是，不进入主线程，而是进入任务队列（task queue），只有当任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行_。

1. 所有的同步任务都在主线程上执行，形成一个**执行栈**。
2. 主线程之外，还有一个**任务队列**。只要异步任务有了结果，就在任务队列中放置一个事件。
3. 一旦执行栈中的**所有同步任务执行完毕**，系统就会读取任务队列，看看里面有哪些事件，那些对应的异步任务，结束等待状态，进入执行栈开始执行。
4. **主线程不断的重复上面的第三步**。

**只要主线程空了，就会去读取任务队列，这就是 javascript 的运行机制。**

## 三、回调函数

**任务队列**是一个事件的队列（也可以认为是消息的队列），IO 设备完成一项任务，就在任务队列中添加一个事件，表示相关的异步任务可以进入**执行栈**。主线程读取**任务队列**，就是读取里边的事件。  
**任务队列**中的事件，除了 IO 设备的事件以外，还包括了一些用户产生的事件（比如鼠标点击，页面滚动）等。只要指定过**回调函数**，这些事件发生时就会进入**任务队列**，等待主线程读取。  
**回调函数**（callback），就是那些被主线程挂起来的代码。**异步任务必须指定回调函数**（不指定回调函数，则无法得知异步任务的成败），当主线程开始执行异步任务时，就是执行的回调函数。  
**任务队列**是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，**任务队列**上第一位的事件就自动进入主进程。但是，由于存在**定时器**功能，主线程首先要检查一下执行时间，某个事件只有到了规定的时间，才能返回主线程。

## 四、Event Loop

> 主线程从**任务队列**中读取事件，这个过程是不断循环的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

**执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）之前执行**。

## 五、定时器

除了异步任务，**任务队列还可以放置定时器，即指定一段时间后执行一段代码**。这就是**定时器**。
定时器主要功能主要由 _setTimeout_ 和 *setInterval*两个函数完成，他们的内部运行机制完全一样，区别在于前者指定的代码是一次性的，后者则是反复执行。他们接收**两个参数**（第三个以及之后的参数为第一个函数参数的参数），第一个参数是**回调函数**，第二个参数是**等待时间**。等待时间指的是在一段时间后的主线程的空闲时间执行。如果是 0，eg: `setTimeout(fn,0)`, 指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早的执行。他在任务队列的尾部添加一个事件，因此要等到**同步任务**和**任务队列**中现有的事件都处理完，才会得到执行。

HTML5 标准规定了 setTimeout 的第二个参数的最小值，不得低于 4ms，就是说，如果低于这个值，也会按照 4ms 执行，在此之前浏览器将最短时间间隔设为 10ms。 对于哪些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16ms 执行一次。这时使用 `requestAnimationFrame()` 的效果要好于 setTimeout（）。 需要注意的是，setTimeout 只是将事件插入了**任务队列**，执行依然要等到主线程执行完毕，读取**任务队列**时，才会执行到 settimeout 的回调函数，如果主线程耗时较长，那么就没有办法保证回调函数一定会在 setTimeout 指定的时间执行。

## 六、Node.js 的 Event Loop

Node.js 也是单线程的 Event Loop， 但是他的运行机制不同于浏览器环境。

1. V8 引擎解析 javascript 脚本。
2. 解析后的代码，调用 Node api。
3. libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop,以异步的方式将任务的执行结果返回给 V8 引擎。
4. V8 引擎再将结果返回给用户。

除了`setTimeout` 和 `setInterval` 这两个方法，Node.js 还提供了另外两个与**任务队列有关的方法**：**process.nextTick**和**setImmediate**。它们可以帮助我们加深对**任务队列的理解**，这两个方法只有一个函数参数。

`process.nextTick` 方法可以在**当前执行栈**的尾部，下一次 Event Loop 之前，触发回调函数。**它总是发生在所有异步任务之前**。  
`setImmediate` 方法则在 **当前任务队列的尾部**添加事件，也就是说，它指定的任务总是在下一次 Event Loop 时执行，这和 `settimeout(fn,0)` 很像。  
最新版 nodejs 推荐使用 `setImmediate`，因为 nextTick 可能阻断 IO。

**如果有多个 process.nextTick 语句（不管它们是否嵌套），将全部在当前"执行栈"执行。**  
**多个 process.nextTick 语句总是在当前"执行栈"一次执行完，多个 setImmediate 可能则需要多次 loop 才能执行完**

```js
// 无限循环
process.nextTick(function foo() {
	process.nextTick(foo);
});
```

**理解 javascript 的 事件循环机制，对程序的理解会更加的深入。**

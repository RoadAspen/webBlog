# EventLoop

javascript 是单线程，非阻塞的，当异步函数完成执行回调时重回到事件循环中。这就是`javascript事件循环机制`。

## 单线程

### 什么是单线程

js 诞生之初就是单线程，主程序只有一个线程，并且同一时间片段内只能执行单个任务。

### 为什么是单线程

js 的单线程主要在于 js 的用途，js 作为浏览器脚本语言，主要用途是为了用户互动、操作 DOM，这决定了它只能是单线程，如果是多线程，那么两个线程同时对同一个 DOM 节点作出修改，一个添加，一个删除，那么浏览器该如何做出展示？ 基于此，javascript 从诞生之初就是单线程，这已经是 javascript 这门语言的核心特征，将来也不会改变。  
为了利用多核 CPU 的计算能力，HTML5 提出了 WebWorker 标准，允许 javascript 创建多个线程，但是 web worker 不能操作 DOM，且子线程完全受主线程控制，本质上并没有改变 javascript 是单线程的事实。

### 单线程意味着什么

就像奶茶店，排号制作奶茶，只有前边的人的订单做好了，才能做好你的
**javascript 是单线程**，单线程就意味着，所有的任务都需要排队，当前一个任务结束，下一个任务才会开始执行。如果一个任务耗时过长，后边的任务就会一直等着。

### 怎么解决单线程的阻塞问题

任务一般分为 **CPU 密集型**，**I/O 密集型** ,js 把任务分为两种，一种是**同步任务**，一种是**异步任务**。异步任务指的是，不进入主线程，而是进入任务队列（task queue），只有当任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

## javascript 内存

### 堆（heap）

堆表示一大块非结构化的内存区域，对象，数据被存放在堆中

### 栈（stack）

栈，又叫执行栈，是一种`后进先出`的数据结构。javascript 有一个主线程和调用栈，主线程的所有任务都会被放到调用栈等待主线程执行。当函数执行时会被添加到栈的顶部，当函数执行完后就会从栈顶移出，直到栈内被清空。

### 队列

**任务队列** 即 Task Queue 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，**任务队列**底部第一个的事件就自动进入主进程。但是，由于存在**定时器**功能，主线程首先要检查一下执行时间，某个事件只有到了规定的时间，才能返回主线程。

## Javascript 代码执行机制

![EventLoop](/js/eventloop/eventloop.jpg)

1. 所有的同步任务都在主线程上执行，形成一个**执行栈(stack)**。
2. 主线程之外，还有一个**任务队列(callback queue)**。只要异步任务有了结果，就在任务队列中放置一个事件。
3. 一旦执行栈中的**所有同步任务执行完毕**，系统就会读取任务队列，看看里面有哪些事件，那些对应的异步任务，结束等待状态，进入执行栈开始执行。
4. **主线程不断的重复上面的第三步**。

### 事件循环

只要主线程执行栈空了，就会去读取任务队列，这就是 javascript 的运行机制 EventLoop。主线程从**任务队列**中读取事件，这个过程是不断循环的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

### 异步任务

js 中的异步任务又分为 微任务 和 宏任务

#### macrotask

宏任务有以下几种：

1. I/O
2. setTimeout
3. setInterval
4. setImmediate(Node 环境)
5. UI rendering(页面重绘)
6. requestAnimationFrame(在下一次页面重绘之前执行)

#### microtask

微任务有以下几种：

1. promise.then
2. process.nextTick(Node 环境)
3. MutationObserver (监视 DOM 变动，DOM 变动会触发这个事件)

在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至两个队列的任务都取完。

## 定时器

除了异步任务，**任务队列还可以放置定时器，即指定一段时间后执行一段代码**。这就是**定时器**。
定时器主要功能主要由 _setTimeout_ 和 *setInterval*两个函数完成，他们的内部运行机制完全一样，区别在于前者指定的代码是一次性的，后者则是反复执行。他们接收**两个参数**（第三个以及之后的参数为第一个函数参数的参数），第一个参数是**回调函数**，第二个参数是**等待时间**。等待时间指的是在一段时间后的主线程的空闲时间执行。如果是 0，eg: `setTimeout(fn,0)`, 指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早的执行。他在任务队列的尾部添加一个事件，因此要等到**同步任务**和**任务队列**中现有的事件都处理完，才会得到执行。

HTML5 标准规定了 setTimeout 的第二个参数的最小值，不得低于 4ms，就是说，如果低于这个值，也会按照 4ms 执行，在此之前浏览器将最短时间间隔设为 10ms。 对于哪些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16ms 执行一次。这时使用 `requestAnimationFrame()` 的效果要好于 setTimeout（）。 需要注意的是，setTimeout 只是将事件插入了**任务队列**，执行依然要等到主线程执行完毕，读取**任务队列**时，才会执行到 settimeout 的回调函数，如果主线程耗时较长，那么就没有办法保证回调函数一定会在 setTimeout 指定的时间执行。

## Node.js 的 Event Loop

Node.js 也是单线程的 Event Loop， 但是他的运行机制不同于浏览器环境。

1. V8 引擎解析 javascript 脚本。
2. 解析后的代码，调用 Node api。
3. libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop,以异步的方式将任务的执行结果返回给 V8 引擎。
4. V8 引擎再将结果返回给用户。

除了`setTimeout` 和 `setInterval` 这两个方法，Node.js 还提供了另外两个与**任务队列有关的方法**：**process.nextTick**和**setImmediate**。它们可以帮助我们加深对**任务队列的理解**，这两个方法只有一个函数参数。

`process.nextTick` 方法可以在**当前执行栈**的尾部，下一次 Event Loop 之前，触发回调函数。**它总是发生在所有异步任务之前**。  
`setImmediate` 方法则在 **当前任务队列的尾部**添加事件，也就是说，它指定的任务总是在下一次 Event Loop 时执行，这和 `settimeout(fn,0)` 很像。  
最新版 nodejs 推荐使用 `setImmediate`，因为 nextTick 可能阻断 IO。

**如果有多个 process.nextTick 语句（不管它们是否嵌套），将全部在当前"执行栈"执行。**  
**多个 process.nextTick 语句总是在当前"执行栈"一次执行完，多个 setImmediate 可能则需要多次 loop 才能执行完**

```js
// 无限循环
process.nextTick(function foo() {
	process.nextTick(foo);
});
```

理解 javascript 的 事件循环机制，对程序的理解会更加的深入。

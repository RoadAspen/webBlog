## 前言
现代操作系统（windows、macOS、Linux）都可以执行多任务。多任务就是同时运行多个任务，例如：同时打开 浏览器、QQ音乐、word。

CPU执行代码是一条一条执行的，但是，即使是单核CPU，也可以同时运行多个任务。因为操作系统执行多个任务实际上是让CPU对多个任务轮流交替执行。

其实对于操作系统来说我们可以控制，让 浏览器执行0.001秒，再让音乐播放器执行0.001秒，再让word执行0.001秒，所以，在我们看来，CPU就是在同时执行多个任务。

即使是多核CPU，因为通常需要同时执行的任务数量是远大于CPU的数量的，所以任务也是交替执行的。

## 进程
在计算机中，我们把一个任务称为一个`进程`，浏览器是一个进程，QQ音乐播放器是一个进程，类似的，音乐播放器和Word都是进程。

`某些进程内部还需要同时执行多个子任务`。例如，我们在使用word时，word可以让我们一边打字，一边校验拼写错误，同时还可以在后台进行打印，我们把`子任务`称为`线程`。

**进程和线程的关系：一个进程可以包含一个或者多个线程，但至少有一个线程。如JS执行就是单进程单线程。**

操作系统调度的最小单位不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

因为同一个应用程序，即可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：

**多进程模式：每个进程只有一个线程。**

**多线程模式：只有一个进程，里边有多个线程（Java）；**

**多进程+多线程模式（复杂度最高）：多个进程，每个进程有多个线程。**

## 进程VS线程
进程和线程是包含的关系，但是多任务即可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程+多线程。

具体采用哪种方式，要考虑到进程和线程的特点：

和多线程相比，多进程的缺点在于：

+ 创建进程比创建线程开销大，尤其是在Windows系统上。
+ 进程间通信比线程间通信慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的有点在于：

**多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。**

## 多线程
Java语言内置了多线程支持：一个java程序实际上是一个JVM进程，JVM进程用一个主线程来执行`main()`方法，在`main()`方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。

因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程来实现多任务。

和单线程相比，**多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。**例如：播放电影时，就必须有一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难、

Java多线程编程的特点又在于：

+ 多线程模型是Java程序最基本的开发模型。
+ 后续读写网络、数据库、Web开发等都依赖Java多线程模型。

因此，必须掌握Java多线程编程才能继续深入学习其他内容。

## 创建一个多线程
当java程序启动时，实际上是启动了一个JVM进程，然后，JVM启动主线程来运行`main（）`方法。在main方法中，我们就可以创建其他线程。

创建一个线程非常容易。我们需要实例化一个 `Thread`实例，然后调用它的start方法：

```java
// 创建多线程
public class Main{
    public static void main(String[] args){
        Thread t = new Thread();
        t.start(); // 启动新线程
    }
}
```

但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新县城能执行指定的代码，有以下几种方法：

**方法一、从**`**Thread**`**派生一个自定义类，然后覆写**`**run()**`**方法：**

```java
// 创建多线程
public class Main{
    public static void main(String[] args){
        Thread t = new MyThread();
        t.start(); // 启动新线程
    }
}

// 创建多线程
public class MyThread extends Thread{
    // 这里复写了创建方法
    @Override
   public void run(){
       System.out.printLn("start a new thread!")
   }
}
```

